Currently the query mechanics and the full text indexing seem to work
and make sense. The datastore abstraction however is being revised in
light of some of the versioning requirements.

The current plan is to use Mecurial (hg) as the underlying filesystem
storage for content objects and their versions. Its fast, written in
Python and write-sensitive (doing forward time deltas rather than the
more common backwards ones).

This will lead to a model of many backingstores for a given
datastore. Each will represent a space, a bulliten board, or what have
you. When users connect to each other for sharing its done in the
context of an activity. Activities will have content assoicated with
them and the datastore is able to locate the backing store the content
lives in (when connected to it). Thus if another user on the network
has the content you want and you're connected and sharing a space with
them you will in effect have a common Mecurial repository under the
backing store API.

This model is used when you attach USB drives and keys as well as when
you connect network servers. Each is a Mecurial repository its own
Query manager. Changes through the API (which they all must be) will
trigger the changes in hg and in the query index. The index is stored
along side the repository and is available whenever one is mounted
(connected by the datastore).
